----
File: ReadMe.md
----
# Chess App for Android

A beginner-friendly chess application built for Android using Kotlin and Jetpack Compose.

## Features (Current)

- ‚úÖ Interactive chess board with 8x8 grid
- ‚úÖ Chess pieces in starting positions with Unicode symbols
- ‚úÖ **Complete chess gameplay mechanics**
- ‚úÖ **Turn-based gameplay** (White moves first, alternating turns)
- ‚úÖ **Full piece movement logic** for all 6 piece types:
    - Pawns: Move forward 1-2 squares, capture diagonally
    - Rooks: Move horizontally/vertically any distance
    - Bishops: Move diagonally any distance
    - Knights: Move in L-shape (2+1 squares)
    - Queens: Combine rook + bishop movement
    - Kings: Move 1 square in any direction
- ‚úÖ **Visual feedback system** with square highlighting and valid move indicators
- ‚úÖ **Move validation** - only legal moves allowed
- ‚úÖ **Game status display** showing current player's turn
- ‚úÖ **Move history** with chess notation (e.g., "e2 ‚Üí e4")
- ‚úÖ **Tap-to-play interface** (select piece, then tap destination)
- ‚úÖ Material Design 3 UI
- ‚úÖ Navigation between home screen and game board

## Features (Planned)

- ‚è≥ **AI opponent** with adjustable difficulty
- ‚è≥ **Advanced chess rules** (check, checkmate, stalemate)
- ‚è≥ **Special moves** (castling, en passant, pawn promotion)
- ‚è≥ **Beginner-friendly hints** and tutorials
- ‚è≥ **Game save/load** functionality
- ‚è≥ **Sound effects** and animations
- ‚è≥ **Captured pieces display**

## How to Play

1. **Start the game** - White pieces move first
2. **Select a piece** - Tap any of your pieces to see valid moves (highlighted in green)
3. **Make your move** - Tap on a highlighted square to move there
4. **Turns alternate** - Game automatically switches to the other player
5. **Continue playing** - Repeat until the game ends

## Technical Details

- **Target Android Version**: Android 10 (API level 29)
- **Language**: Kotlin
- **UI Framework**: Jetpack Compose
- **Architecture**: Modern Android development practices
- **Chess Logic**: Complete rule implementation for all piece types

## Development Setup

1. Clone the repository
2. Open in Android Studio
3. Build and run on device or emulator

## Current Progress

This project is being developed iteratively with the following steps:

1. ‚úÖ **Basic Setup**: Project structure and simple UI
2. ‚úÖ **Chess Board UI**: Interactive board with pieces
3. ‚úÖ **Game Logic**: Complete chess gameplay mechanics (**MAJOR MILESTONE**)
4. ‚è≥ **AI Implementation**: Bot opponent
5. ‚è≥ **Advanced Rules**: Check, checkmate, special moves
6. ‚è≥ **UI/UX Enhancement**: Beginner-friendly features

## Testing

**Tested on:**
- Android Studio Emulator (Android 10)
- **Target**: Samsung Galaxy S9 (Android 10)

**Current Testing Status:**
- ‚úÖ All piece movements working correctly
- ‚úÖ Turn-based gameplay functioning
- ‚úÖ Move validation preventing illegal moves
- ‚úÖ Visual feedback system working
- ‚úÖ Game state tracking operational

## Game Rules Implemented

### Basic Piece Movement
- **Pawns**: Move forward 1 square, or 2 from starting position; capture diagonally
- **Rooks**: Move any number of squares horizontally or vertically
- **Bishops**: Move any number of squares diagonally
- **Knights**: Move in L-shape (2 squares in one direction, 1 perpendicular)
- **Queens**: Combine rook and bishop movement
- **Kings**: Move 1 square in any direction

### Game Flow
- White always moves first
- Players alternate turns
- Only current player's pieces can be moved
- Visual indicators show valid moves
- Game tracks complete move history

## Development Notes

This is a **fully playable chess game** with complete basic chess rules implemented. The app currently supports human vs human gameplay with proper turn management and move validation. The next major milestone is implementing an AI opponent to enable single-player gameplay.

## Version History

- **v0.3** - Complete chess gameplay mechanics (Step 3)
- **v0.2** - Interactive chess board UI (Step 2)
- **v0.1** - Basic project setup and navigation (Step 1)

----
File: TODO.md
----
# Chess App Development TODO

## Project Overview
**Target Android Version**: Android 10 (API level 29)  
**Test Device**: Galaxy S9 (runs Android 10)  
**App Purpose**: A chess app for beginners and casual players

### Core Features
- [x] Play against bots
- [ ] Bots should be adjustable
  - [ ] Players can choose any difficulty Level 0.0-50.0
  - [ ] Game over suggests next difficulty
- [x] Intuitive and beginner-friendly UI

### Development Approach
- [x] Add one feature at a time
- [x] Test after each step

### DEVELOPMENT CONSTRAINT RULE
üîí **MINIMAL CODE UPDATE CONSTRAINT** üîí
- **Write all of the actual code that would be changed**
- **But minimally - don't write the whole file**
- **Show only the specific parts being added or modified**
- **For removed code, just describe what needs removed (e.g., function signatures)**
- **This constraint ensures focused, manageable development steps**
- **Always specify the exact location and what would be modified**

---

## Development Steps

### Step 1: Setup project and basic UI ‚úÖ
- [x] Create a new Android Studio project targeting Android 10
- [x] Show a simple home screen with a "Play" button
- [x] Run and test this on emulator
- [x] Set up Git repository and version control

### Step 2: Basic chess board UI without game logic ‚úÖ
- [x] Display chess board with 8x8 grid
- [x] Initialize chess pieces in starting positions
- [x] Add visual distinction between light/dark squares
- [x] Implement square selection with visual feedback
- [x] Add navigation between home screen and chess board
- [x] Test board display and selection functionality

### Step 3: Implement chess game logic ‚úÖ
- [x] Add basic piece movement (tap to select, tap to move)
- [x] Implement turn-based gameplay (white/black alternating)
- [x] Add move validation for each piece type:
  - [x] Pawn movement (forward, capture diagonally)
  - [x] Rook movement (horizontal/vertical)
  - [x] Bishop movement (diagonal)
  - [x] Knight movement (L-shape)
  - [x] Queen movement (combination of rook/bishop)
  - [x] King movement (one square in any direction)
- [x] Add visual feedback for valid moves
- [x] Implement game state management and turn tracking
- [x] Add move history display
- [x] Test piece movement and rule validation
### Step 4: Add a simple AI bot ‚úÖ (mostly complete)
- [x] Create basic bot that makes random legal moves
- [x] Allow playing against this bot
- [x] Add game mode selection (Human vs Human / Human vs AI)
- [x] Implement AI thinking delay for realism
- [x] Add AI status display ("AI is thinking...")
- [ ] **BUG FIX**: Fix game status text - currently shows wrong player after moves
- [ ] **FEATURE**: Highlight AI's last move (from and to squares) for better visibility
- [ ] **REFACTOR**: Move duplicate chess logic to shared utility class
- [ ] **TESTING**: Test AI bot gameplay extensively
- [ ] **POLISH**: Add game mode selection UI on home screen ‚úÖ

#### Step 4 Remaining Tasks:
1. **Bug Fixes** (HIGH PRIORITY)
  - Fix game status text logic (currently backwards)
  - Add AI move highlighting (show from/to squares of last AI move)

2. **Code Refactoring** (HIGH PRIORITY)
  - Create `ChessLogic.kt` or `ChessUtils.kt` to eliminate duplicate code
  - Move `getValidMoves()`, `getRookMoves()`, `getBishopMoves()`, `isValidPosition()` to shared file
  - Update both `ChessAI.kt` and `ChessBoard.kt` to use shared logic

3. **UI Improvements**
  - Add game mode selection on home screen ‚úÖ
  - Improve AI status messages
  - Add restart game functionality

4. **Testing & Bug Fixes**
  - Test AI moves thoroughly
  - Ensure AI cannot move human pieces
  - Test edge cases (no valid moves, etc.)

### Step 5: Improve AI difficulty üîÑ (next major step)
- [ ] **REFACTOR FIRST**: Complete Step 4 refactoring before starting
- [ ] Implement adaptive difficulty system (Level 0.0-50.0)
- [ ] Create difficulty slider/picker in settings
- [ ] Implement move evaluation algorithm that can be tuned
- [ ] Add post-game difficulty suggestions based on performance
- [ ] Add bot "thinking" time variation based on difficulty
- [ ] Test and balance difficulty across full range

### Step 6: Add advanced chess rules üîÑ
- [ ] Implement check detection
- [ ] Prevent moves that would leave king in check
- [ ] Add checkmate detection
- [ ] Add stalemate detection
- [ ] Implement castling (kingside and queenside)
- [ ] Add en passant capture
- [ ] Implement pawn promotion
- [ ] Test all special rules

### Step 7: Enhance UI/UX üîÑ
- [ ] Add hints and move suggestions for beginners
- [ ] Show captured pieces
- [ ] Add game settings (difficulty, hints on/off)
- [ ] Add beginner-friendly features like explanations
- [ ] Improve visual design and animations
- [ ] Add sound effects for moves
- [ ] Implement piece animations for moves

### Step 8: Testing & polishing üîÑ
- [ ] Test extensively on Galaxy S9
- [ ] Fix bugs and improve performance
- [ ] Add app icon and branding
- [ ] Test edge cases and error handling
- [ ] Optimize for different screen sizes
- [ ] Add game save/load functionality

---

## Current Status
**Last Updated**: Step 4 mostly completed - AI bot implemented but needs refactoring  
**Next Priority**: Complete Step 4 refactoring, then move to Step 5 (difficulty system)  
**Testing Status**: ‚úÖ Basic AI functionality working, needs thorough testing

## Major Accomplishments
### Step 4 - AI Bot Implementation ‚úÖ (mostly complete)
- ‚úÖ Basic AI that makes random legal moves
- ‚úÖ Human vs AI game mode implemented
- ‚úÖ AI thinking delay and status messages
- ‚úÖ Proper turn management preventing human moves during AI turn
- ‚úÖ Game mode enum and logic separation

## Critical Issues to Address (Step 4 Completion)
### 1. Code Duplication (HIGH PRIORITY)
- `getValidMoves()` logic is duplicated in `ChessAI.kt` and `ChessBoard.kt`
- `getRookMoves()`, `getBishopMoves()`, `isValidPosition()` are duplicated
- This creates maintenance burden and potential for bugs
- **SOLUTION**: Create shared `ChessLogic.kt` utility class

### 2. Missing UI Features
- No game mode selection on home screen
- No way to restart game
- Limited game status information

### 3. Testing Gaps
- AI move validation needs thorough testing
- Edge cases not fully tested
- Performance testing needed

## Code Structure Improvements Needed
```
Current Structure:
- ChessBoard.kt (contains UI + some game logic)
- ChessAI.kt (contains AI + duplicated game logic)
- ChessModels.kt (missing - needs to be created)

Proposed Structure:
- ChessBoard.kt (UI only)
- ChessAI.kt (AI logic only)
- ChessLogic.kt (shared game logic)
- ChessModels.kt (data classes)
```

## Next Immediate Steps
1. **Create `ChessLogic.kt`** - Move shared logic here
2. **Create `ChessModels.kt`** - Move data classes here
3. **Update home screen** - Add game mode selection
4. **Add restart functionality**
5. **Test thoroughly** - Ensure AI works correctly
6. **Then proceed to Step 5** - Difficulty system

## Notes
- **AI bot is functional** but code needs cleanup
- **Human vs AI gameplay working** - AI makes random moves
- **Foundation is solid** for adding difficulty system
- **Major refactoring needed** before proceeding to Step 5
- Current AI makes purely random moves (Level 0.0 equivalent)

## Testing Checklist for Step 4 Completion
- [ ] AI makes only legal moves
- [ ] AI cannot move during human turn
- [ ] Human cannot move during AI turn
- [ ] Game alternates turns correctly
- [ ] AI thinking delay works
- [ ] All piece types move correctly for AI
- [ ] No crashes or exceptions
- [ ] Memory usage acceptable
- [ ] Performance smooth on target device

## Version History
- **v0.4** - AI bot implementation (Step 4 - mostly complete)
- **v0.3** - Complete chess gameplay mechanics (Step 3)
- **v0.2** - Interactive chess board UI (Step 2)
- **v0.1** - Basic project setup and navigation (Step 1)

----
File: app\src\main\AndroidManifest.xml
----
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.ChessApp"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.ChessApp">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

----
File: app\src\main\java\com\example\android\chessapp\ChessAI.kt
----
package com.example.android.chessapp

import kotlinx.coroutines.delay
import kotlin.random.Random

/**
 * Simple AI bot that makes random legal moves
 * This is the foundation for the difficulty system that will be added in Step 5
 */
class ChessAI {

    /**
     * Makes a move for the AI bot
     * Currently uses random move selection
     * @param board Current board state
     * @param color AI's color (BLACK or WHITE)
     * @param onMove Callback when move is selected
     */
    suspend fun makeMove(
        board: Array<Array<ChessPiece?>>,
        color: PieceColor,
        onMove: (ChessMove) -> Unit
    ) {
        // Add thinking delay for realistic feel
        delay(Random.nextLong(500, 1500))

        val allPossibleMoves = getAllPossibleMoves(board, color)

        if (allPossibleMoves.isNotEmpty()) {
            val randomMove = allPossibleMoves.random()
            onMove(randomMove)
        }
    }

    /**
     * Gets all possible moves for the given color
     */
    private fun getAllPossibleMoves(
        board: Array<Array<ChessPiece?>>,
        color: PieceColor
    ): List<ChessMove> {
        val moves = mutableListOf<ChessMove>()

        // Find all pieces of the given color
        for (row in 0..7) {
            for (col in 0..7) {
                val piece = board[row][col]
                if (piece?.color == color) {
                    val position = ChessPosition(row, col)
                    val validMoves = getValidMoves(position, board)

                    // Convert positions to moves
                    validMoves.forEach { targetPos ->
                        val capturedPiece = board[targetPos.row][targetPos.col]
                        moves.add(ChessMove(position, targetPos, piece, capturedPiece))
                    }
                }
            }
        }

        return moves
    }

    /**
     * Gets valid moves for a piece at the given position
     * This uses the same logic as the human player
     */
    private fun getValidMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>): List<ChessPosition> {
        return ChessLogic.getValidMoves(position, board)
    }

    private fun getRookMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>, color: PieceColor): List<ChessPosition> {
        val moves = mutableListOf<ChessPosition>()
        val directions = listOf(
            Pair(0, 1), Pair(0, -1), Pair(1, 0), Pair(-1, 0)
        )

        directions.forEach { (rowDir, colDir) ->
            var currentRow = position.row + rowDir
            var currentCol = position.col + colDir

            while (isValidPosition(ChessPosition(currentRow, currentCol))) {
                val targetPiece = board[currentRow][currentCol]
                if (targetPiece == null) {
                    moves.add(ChessPosition(currentRow, currentCol))
                } else {
                    if (targetPiece.color != color) {
                        moves.add(ChessPosition(currentRow, currentCol))
                    }
                    break
                }
                currentRow += rowDir
                currentCol += colDir
            }
        }

        return moves
    }

    private fun getBishopMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>, color: PieceColor): List<ChessPosition> {
        val moves = mutableListOf<ChessPosition>()
        val directions = listOf(
            Pair(1, 1), Pair(1, -1), Pair(-1, 1), Pair(-1, -1)
        )

        directions.forEach { (rowDir, colDir) ->
            var currentRow = position.row + rowDir
            var currentCol = position.col + colDir

            while (isValidPosition(ChessPosition(currentRow, currentCol))) {
                val targetPiece = board[currentRow][currentCol]
                if (targetPiece == null) {
                    moves.add(ChessPosition(currentRow, currentCol))
                } else {
                    if (targetPiece.color != color) {
                        moves.add(ChessPosition(currentRow, currentCol))
                    }
                    break
                }
                currentRow += rowDir
                currentCol += colDir
            }
        }

        return moves
    }

    private fun isValidPosition(position: ChessPosition): Boolean {
        return position.row in 0..7 && position.col in 0..7
    }
}

----
File: app\src\main\java\com\example\android\chessapp\ChessBoard.kt
----
package com.example.android.chessapp

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.itemsIndexed
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch

enum class GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
}

@Composable
fun ChessBoard(
    modifier: Modifier = Modifier,
    gameMode: GameMode = GameMode.HUMAN_VS_AI
) {
    // Game state
    var board by remember { mutableStateOf(initializeBoard()) }
    var currentPlayer by remember { mutableStateOf(PieceColor.WHITE) }
    var selectedPosition by remember { mutableStateOf<ChessPosition?>(null) }
    var validMoves by remember { mutableStateOf<List<ChessPosition>>(emptyList()) }
    var moveHistory by remember { mutableStateOf<List<ChessMove>>(emptyList()) }
    var gameStatus by remember { mutableStateOf("White to move") }
    var isAiThinking by remember { mutableStateOf(false) }
    var lastAiMove by remember { mutableStateOf<ChessMove?>(null) }

    // AI instance
    val chessAI = remember { ChessAI() }
    val coroutineScope = rememberCoroutineScope()

    // AI move handler
    val handleAiMove = { move: ChessMove ->
        val newBoard = board.map { it.clone() }.toTypedArray()
        newBoard[move.to.row][move.to.col] = move.piece
        newBoard[move.from.row][move.from.col] = null

        board = newBoard
        moveHistory = moveHistory + move
        currentPlayer = if (currentPlayer == PieceColor.WHITE) PieceColor.BLACK else PieceColor.WHITE
        selectedPosition = null
        validMoves = emptyList()
        isAiThinking = false
        gameStatus = "${if (currentPlayer == PieceColor.WHITE) "White" else "Black"} to move"
        lastAiMove = move
    }

    // Trigger AI move when it's AI's turn
    LaunchedEffect(currentPlayer, gameMode) {
        if (gameMode == GameMode.HUMAN_VS_AI &&
            currentPlayer == PieceColor.BLACK &&
            !isAiThinking) {
            isAiThinking = true
            gameStatus = "AI is thinking..."

            coroutineScope.launch {
                chessAI.makeMove(board, PieceColor.BLACK, handleAiMove)
            }
        }
    }

    Column(
        modifier = modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        // Game mode indicator
        Text(
            text = when (gameMode) {
                GameMode.HUMAN_VS_HUMAN -> "Human vs Human"
                GameMode.HUMAN_VS_AI -> "Human vs AI"
            },
            style = MaterialTheme.typography.bodyMedium,
            modifier = Modifier.padding(8.dp)
        )

        // Game status
        Text(
            text = gameStatus,
            style = MaterialTheme.typography.headlineSmall,
            modifier = Modifier.padding(16.dp)
        )

        // Chess board
        LazyVerticalGrid(
            columns = GridCells.Fixed(8),
            modifier = Modifier
                .aspectRatio(1f)
                .padding(16.dp)
        ) {
            itemsIndexed(board.flatten()) { index, piece ->
                val row = index / 8
                val col = index % 8
                val position = ChessPosition(row, col)
                val isSelected = selectedPosition == position
                val isValidMove = validMoves.contains(position)

                ChessSquare(
                    piece = piece,
                    position = position,
                    isLight = (row + col) % 2 == 0,
                    isSelected = isSelected,
                    isValidMove = isValidMove,
                    lastAiMove = lastAiMove,
                    onClick = {
                        // Only allow human moves when it's not AI's turn or AI is not thinking
                        if (gameMode == GameMode.HUMAN_VS_HUMAN ||
                            (gameMode == GameMode.HUMAN_VS_AI && currentPlayer == PieceColor.WHITE && !isAiThinking)) {
                            handleSquareClick(
                                position = position,
                                board = board,
                                selectedPosition = selectedPosition,
                                currentPlayer = currentPlayer,
                                validMoves = validMoves,
                                onMove = { newBoard, move ->
                                    board = newBoard
                                    moveHistory = moveHistory + move
                                    currentPlayer = if (currentPlayer == PieceColor.WHITE) PieceColor.BLACK else PieceColor.WHITE
                                    selectedPosition = null
                                    validMoves = emptyList()
                                    gameStatus = "${if (currentPlayer == PieceColor.WHITE) "White" else "Black"} to move"
                                },
                                onSelection = { pos, moves ->
                                    selectedPosition = pos
                                    validMoves = moves
                                }
                            )
                        }
                    }
                )
            }
        }

        // Selected position and move info
        selectedPosition?.let { pos ->
            val piece = board[pos.row][pos.col]
            Text(
                text = "Selected: ${positionToAlgebraic(pos)}" +
                        if (piece != null) " - ${piece.color} ${piece.type}" else " - Empty",
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.padding(8.dp)
            )
        }

        // Last move info
        moveHistory.lastOrNull()?.let { lastMove ->
            Text(
                text = "Last move: ${lastMove.piece.color} ${lastMove.piece.type} " +
                        "${positionToAlgebraic(lastMove.from)} ‚Üí ${positionToAlgebraic(lastMove.to)}",
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.padding(8.dp)
            )
        }

        // Move count
        Text(
            text = "Move ${moveHistory.size + 1}",
            style = MaterialTheme.typography.bodySmall,
            modifier = Modifier.padding(4.dp)
        )
    }
}

@Composable
fun ChessSquare(
    piece: ChessPiece?,
    position: ChessPosition,
    isLight: Boolean,
    isSelected: Boolean,
    isValidMove: Boolean,
    lastAiMove: ChessMove?,
    onClick: () -> Unit
) {
    val isLastAiMove = lastAiMove?.let {
        it.from == position || it.to == position
    } ?: false

    val backgroundColor = when {
        isSelected -> Color(0xFF4CAF50) // Green for selected
        isLastAiMove -> Color(0xFFFFEB3B) // Yellow for last AI move
        isValidMove -> Color(0xFF81C784) // Light green for valid moves
        isLight -> Color(0xFFF0D9B5) // Light squares
        else -> Color(0xFFB58863) // Dark squares
    }

    Box(
        modifier = Modifier
            .aspectRatio(1f)
            .background(backgroundColor)
            .border(
                width = if (isSelected) 2.dp else 0.dp,
                color = Color.Black
            )
            .clickable { onClick() },
        contentAlignment = Alignment.Center
    ) {
        piece?.let {
            Text(
                text = getPieceSymbol(it),
                fontSize = 24.sp,
                fontWeight = FontWeight.Bold,
                textAlign = TextAlign.Center,
                color = if (it.color == PieceColor.WHITE) Color.White else Color.Black
            )
        }

        // Show dot for valid move on empty square
        if (isValidMove && piece == null) {
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(Color.Green.copy(alpha = 0.7f), shape = androidx.compose.foundation.shape.CircleShape)
            )
        }
    }
}

private fun handleSquareClick(
    position: ChessPosition,
    board: Array<Array<ChessPiece?>>,
    selectedPosition: ChessPosition?,
    currentPlayer: PieceColor,
    validMoves: List<ChessPosition>,
    onMove: (Array<Array<ChessPiece?>>, ChessMove) -> Unit,
    onSelection: (ChessPosition?, List<ChessPosition>) -> Unit
) {
    if (selectedPosition != null && validMoves.contains(position)) {
        // Execute move
        val piece = board[selectedPosition.row][selectedPosition.col]!!
        val capturedPiece = board[position.row][position.col]

        val newBoard = board.map { it.clone() }.toTypedArray()
        newBoard[position.row][position.col] = piece
        newBoard[selectedPosition.row][selectedPosition.col] = null

        val move = ChessMove(selectedPosition, position, piece, capturedPiece)
        onMove(newBoard, move)
    } else {
        // Select piece
        val piece = board[position.row][position.col]
        if (piece != null && piece.color == currentPlayer) {
            val moves = getValidMoves(position, board)
            onSelection(position, moves)
        } else {
            onSelection(null, emptyList())
        }
    }
}

private fun getValidMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>): List<ChessPosition> {
    return ChessLogic.getValidMoves(position, board)
}

private fun positionToAlgebraic(position: ChessPosition): String {
    return "${('a' + position.col)}${8 - position.row}"
}

private fun getPieceSymbol(piece: ChessPiece): String {
    return when (piece.type) {
        PieceType.KING -> if (piece.color == PieceColor.WHITE) "‚ôî" else "‚ôö"
        PieceType.QUEEN -> if (piece.color == PieceColor.WHITE) "‚ôï" else "‚ôõ"
        PieceType.ROOK -> if (piece.color == PieceColor.WHITE) "‚ôñ" else "‚ôú"
        PieceType.BISHOP -> if (piece.color == PieceColor.WHITE) "‚ôó" else "‚ôù"
        PieceType.KNIGHT -> if (piece.color == PieceColor.WHITE) "‚ôò" else "‚ôû"
        PieceType.PAWN -> if (piece.color == PieceColor.WHITE) "‚ôô" else "‚ôü"
    }
}

private fun initializeBoard(): Array<Array<ChessPiece?>> {
    val board = Array(8) { Array<ChessPiece?>(8) { null } }

    // Place black pieces (top of board)
    board[0][0] = ChessPiece(PieceType.ROOK, PieceColor.BLACK)
    board[0][1] = ChessPiece(PieceType.KNIGHT, PieceColor.BLACK)
    board[0][2] = ChessPiece(PieceType.BISHOP, PieceColor.BLACK)
    board[0][3] = ChessPiece(PieceType.QUEEN, PieceColor.BLACK)
    board[0][4] = ChessPiece(PieceType.KING, PieceColor.BLACK)
    board[0][5] = ChessPiece(PieceType.BISHOP, PieceColor.BLACK)
    board[0][6] = ChessPiece(PieceType.KNIGHT, PieceColor.BLACK)
    board[0][7] = ChessPiece(PieceType.ROOK, PieceColor.BLACK)

    // Place black pawns
    for (col in 0..7) {
        board[1][col] = ChessPiece(PieceType.PAWN, PieceColor.BLACK)
    }

    // Place white pawns
    for (col in 0..7) {
        board[6][col] = ChessPiece(PieceType.PAWN, PieceColor.WHITE)
    }

    // Place white pieces (bottom of board)
    board[7][0] = ChessPiece(PieceType.ROOK, PieceColor.WHITE)
    board[7][1] = ChessPiece(PieceType.KNIGHT, PieceColor.WHITE)
    board[7][2] = ChessPiece(PieceType.BISHOP, PieceColor.WHITE)
    board[7][3] = ChessPiece(PieceType.QUEEN, PieceColor.WHITE)
    board[7][4] = ChessPiece(PieceType.KING, PieceColor.WHITE)
    board[7][5] = ChessPiece(PieceType.BISHOP, PieceColor.WHITE)
    board[7][6] = ChessPiece(PieceType.KNIGHT, PieceColor.WHITE)
    board[7][7] = ChessPiece(PieceType.ROOK, PieceColor.WHITE)

    return board
}

----
File: app\src\main\java\com\example\android\chessapp\ChessLogic.kt
----
package com.example.android.chessapp

object ChessLogic {
    public fun getValidMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>): List<ChessPosition> {
        val piece = board[position.row][position.col] ?: return emptyList()
        val moves = mutableListOf<ChessPosition>()

        when (piece.type) {
            PieceType.PAWN -> {
                val direction = if (piece.color == PieceColor.WHITE) -1 else 1
                val startRow = if (piece.color == PieceColor.WHITE) 6 else 1

                // Move forward
                val oneStep = ChessPosition(position.row + direction, position.col)
                if (isValidPosition(oneStep) && board[oneStep.row][oneStep.col] == null) {
                    moves.add(oneStep)

                    // Two steps from starting position
                    if (position.row == startRow) {
                        val twoSteps = ChessPosition(position.row + 2 * direction, position.col)
                        if (isValidPosition(twoSteps) && board[twoSteps.row][twoSteps.col] == null) {
                            moves.add(twoSteps)
                        }
                    }
                }

                // Capture diagonally
                listOf(-1, 1).forEach { colOffset ->
                    val capturePos = ChessPosition(position.row + direction, position.col + colOffset)
                    if (isValidPosition(capturePos)) {
                        val targetPiece = board[capturePos.row][capturePos.col]
                        if (targetPiece != null && targetPiece.color != piece.color) {
                            moves.add(capturePos)
                        }
                    }
                }
            }

            PieceType.ROOK -> {
                moves.addAll(getRookMoves(position, board, piece.color))
            }

            PieceType.BISHOP -> {
                moves.addAll(getBishopMoves(position, board, piece.color))
            }

            PieceType.QUEEN -> {
                moves.addAll(getRookMoves(position, board, piece.color))
                moves.addAll(getBishopMoves(position, board, piece.color))
            }

            PieceType.KNIGHT -> {
                val knightMoves = listOf(
                    ChessPosition(position.row + 2, position.col + 1),
                    ChessPosition(position.row + 2, position.col - 1),
                    ChessPosition(position.row - 2, position.col + 1),
                    ChessPosition(position.row - 2, position.col - 1),
                    ChessPosition(position.row + 1, position.col + 2),
                    ChessPosition(position.row + 1, position.col - 2),
                    ChessPosition(position.row - 1, position.col + 2),
                    ChessPosition(position.row - 1, position.col - 2)
                )

                knightMoves.forEach { move ->
                    if (isValidPosition(move)) {
                        val targetPiece = board[move.row][move.col]
                        if (targetPiece == null || targetPiece.color != piece.color) {
                            moves.add(move)
                        }
                    }
                }
            }

            PieceType.KING -> {
                for (rowOffset in -1..1) {
                    for (colOffset in -1..1) {
                        if (rowOffset == 0 && colOffset == 0) continue
                        val kingMove = ChessPosition(position.row + rowOffset, position.col + colOffset)
                        if (isValidPosition(kingMove)) {
                            val targetPiece = board[kingMove.row][kingMove.col]
                            if (targetPiece == null || targetPiece.color != piece.color) {
                                moves.add(kingMove)
                            }
                        }
                    }
                }
            }
        }

        return moves
    }

    private fun getRookMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>, color: PieceColor): List<ChessPosition> {
        val moves = mutableListOf<ChessPosition>()
        val directions = listOf(
            Pair(0, 1), Pair(0, -1), Pair(1, 0), Pair(-1, 0)
        )

        directions.forEach { (rowDir, colDir) ->
            var currentRow = position.row + rowDir
            var currentCol = position.col + colDir

            while (isValidPosition(ChessPosition(currentRow, currentCol))) {
                val targetPiece = board[currentRow][currentCol]
                if (targetPiece == null) {
                    moves.add(ChessPosition(currentRow, currentCol))
                } else {
                    if (targetPiece.color != color) {
                        moves.add(ChessPosition(currentRow, currentCol))
                    }
                    break
                }
                currentRow += rowDir
                currentCol += colDir
            }
        }

        return moves
    }

    private fun getBishopMoves(position: ChessPosition, board: Array<Array<ChessPiece?>>, color: PieceColor): List<ChessPosition> {
        val moves = mutableListOf<ChessPosition>()
        val directions = listOf(
            Pair(1, 1), Pair(1, -1), Pair(-1, 1), Pair(-1, -1)
        )

        directions.forEach { (rowDir, colDir) ->
            var currentRow = position.row + rowDir
            var currentCol = position.col + colDir

            while (isValidPosition(ChessPosition(currentRow, currentCol))) {
                val targetPiece = board[currentRow][currentCol]
                if (targetPiece == null) {
                    moves.add(ChessPosition(currentRow, currentCol))
                } else {
                    if (targetPiece.color != color) {
                        moves.add(ChessPosition(currentRow, currentCol))
                    }
                    break
                }
                currentRow += rowDir
                currentCol += colDir
            }
        }

        return moves
    }

    private fun isValidPosition(position: ChessPosition): Boolean {
        return position.row in 0..7 && position.col in 0..7
    }
}

----
File: app\src\main\java\com\example\android\chessapp\ChessModels.kt
----
package com.example.android.chessapp

data class ChessPosition(val row: Int, val col: Int)

data class ChessPiece(val type: PieceType, val color: PieceColor)

data class ChessMove(
    val from: ChessPosition,
    val to: ChessPosition,
    val piece: ChessPiece,
    val capturedPiece: ChessPiece? = null
)

enum class PieceType {
    PAWN, ROOK, KNIGHT, BISHOP, QUEEN, KING
}

enum class PieceColor {
    WHITE, BLACK
}

----
File: app\src\main\java\com\example\android\chessapp\MainActivity.kt
----
package com.example.android.chessapp

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.android.chessapp.ui.theme.ChessAppTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChessAppTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ChessApp()
                }
            }
        }
    }
}

@Composable
fun ChessApp() {
    var showBoard by remember { mutableStateOf(false) }
    var gameMode by remember { mutableStateOf(GameMode.HUMAN_VS_AI) }

    if (showBoard) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            // Back button
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.Start
            ) {
                Button(
                    onClick = { showBoard = false }
                ) {
                    Text("‚Üê Back")
                }
            }

            // Chess board with selected game mode
            ChessBoard(
                modifier = Modifier.weight(1f),
                gameMode = gameMode
            )
        }
    } else {
        // Home screen with game mode selection
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Text(
                    text = "Chess App",
                    style = MaterialTheme.typography.headlineLarge,
                    modifier = Modifier.padding(bottom = 32.dp)
                )

                // Game mode buttons
                Button(
                    onClick = {
                        gameMode = GameMode.HUMAN_VS_HUMAN
                        showBoard = true
                    },
                    modifier = Modifier.padding(8.dp)
                ) {
                    Text("Play vs Human")
                }

                Button(
                    onClick = {
                        gameMode = GameMode.HUMAN_VS_AI
                        showBoard = true
                    },
                    modifier = Modifier.padding(8.dp)
                ) {
                    Text("Play vs AI")
                }
            }
        }
    }
}

----
File: app\src\main\java\com\example\android\chessapp\ui\theme\Color.kt
----
package com.example.android.chessapp.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

----
File: app\src\main\java\com\example\android\chessapp\ui\theme\Theme.kt
----
package com.example.android.chessapp.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun ChessAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

----
File: app\src\main\java\com\example\android\chessapp\ui\theme\Type.kt
----
package com.example.android.chessapp.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

----
File: app\src\main\res\values\strings.xml
----
<resources>
    <string name="app_name">ChessApp</string>
</resources>

